#!/usr/bin/env python
import hbp_nrp_excontrol.nrp_states as states
from smach import StateMachine
from smach.state import State
import hbp_nrp_excontrol.nrp_states as states

from gazebo_msgs.srv import ApplyBodyWrench, GetModelState, DeleteModel, SpawnEntity, SpawnEntityRequest
from geometry_msgs.msg import Wrench, Vector3, Point
from std_msgs.msg import Float32
import rospy
from rospy import ServiceProxy, wait_for_service


import smach_ros
import smach
from smach import CBState
from smach import StateMachine
from smach_ros import ServiceState
from hbp_nrp_excontrol.nrp_states import WaitToClockState, ClockDelayState, LinkPoseMonitorState
import rospy
from std_msgs.msg import String
from gazebo_msgs.srv import SetModelState
from gazebo_msgs.msg import ModelState
from hbp_nrp_excontrol.logs import clientLogger

cylinder_name = "cylinder"
cylinder_sdf_xml = """
<?xml version='1.0'?>
<sdf version='1.5'>
  <model name='{cylinder_name}'>
    <pose frame="">-0.37797 -0.25321 1.12015 0 0 0</pose>
    <static>0</static>
    <link name='{cylinder_name}'>
      <pose frame="">0 0 0 0 0 0</pose>
      <inertial>
        <mass>0.1</mass>
        <inertia>
          <ixx>0.000129</ixx>
          <ixy>0</ixy>
          <ixz>0</ixz>
          <iyy>0.000129</iyy>
          <iyz>0</iyz>
          <izz>3.78e-05</izz>
        </inertia>
      </inertial>
      <collision name="collision">
        <geometry>
          <cylinder>
            <radius>0.0275</radius>
            <length>0.115</length>
          </cylinder>
        </geometry>
        <max_contacts>10</max_contacts>
        <surface>
          <contact>
            <ode/>
          </contact>
          <bounce/>
          <friction>
            <torsional>
              <ode/>
            </torsional>
            <ode/>
          </friction>
        </surface>
      </collision>
      <visual name="visual">
        <geometry>
          <cylinder>
            <radius>0.0275</radius>
            <length>0.115</length>
          </cylinder>
        </geometry>
        <material>
          <script>
            <uri>file://media/materials/scripts/gazebo.material</uri>
            <name>Gazebo/Blue</name>
          </script>
        </material>
      </visual>
      <self_collide>0</self_collide>
      <kinematic>0</kinematic>
      <gravity>1</gravity>
    </link>
  </model>
</sdf>
"""

class NewCylinderState(State):
    def __init__(self, cylinder_name, sdf_xml, outcomes=['success', 'aborted']):
        super(NewCylinderState, self).__init__(outcomes=outcomes)
        self._cylinder_name = cylinder_name
        self._spawn_proxy = rospy.ServiceProxy('/gazebo/spawn_sdf_entity',
                                               SpawnEntity, persistent=True)
        self._cylinder_msg = SpawnEntityRequest()
        self._cylinder_msg.entity_name = self._cylinder_name
        self._cylinder_msg.entity_xml = sdf_xml.format(cylinder_name=cylinder_name)
        self._cylinder_msg.initial_pose.position.x = -0.37797
        self._cylinder_msg.initial_pose.position.y = -0.25321
        self._cylinder_msg.initial_pose.position.z = 1.12015
        self._cylinder_msg.reference_frame = "world"

    def execute(self, userdata):
        self._spawn_proxy(self._cylinder_msg)
        return 'success'

class FlyingCylinderState(State):
    def __init__(self, cylinder_name, rate=1., outcomes=['success', 'aborted'], max_hit_duration=10):
        super(FlyingCylinderState, self).__init__(outcomes=outcomes)
        self._rate = rospy.Rate(rate)
        self._cylinder_name = cylinder_name
        self._state_proxy = ServiceProxy('/gazebo/get_model_state',
                                         GetModelState, persistent=True)
        self._delete_proxy = ServiceProxy('/gazebo/delete_model',
                                         DeleteModel, persistent=True)
        self._distance_topic = rospy.Publisher('/cylinder_distance', Float32, queue_size=10)
        self.max_hit_duration=10

    def execute(self, userdata):
        start_time = rospy.Time.now()
        while not self.cylinder_lower_than(0.2) and (rospy.Time.now() - start_time) < rospy.Duration(self.max_hit_duration):
            self._rate.sleep()
        cylinder_pos = self.get_cylinder_distance()
        clientLogger.advertise("Cylinder distance: {}".format(cylinder_pos))
        self._distance_topic.publish(Float32(cylinder_pos))
        self._delete_proxy(self._cylinder_name)
        return 'success'

    def get_cylinder_distance(self):
      try:
          current_cylinder_state = self._state_proxy(cylinder_name, "world")
      except rospy.ServiceException as exc:
          clientLogger.error(str(exc))
          return -1000.0
      return -current_cylinder_state.pose.position.y

    def cylinder_lower_than(self, z_threshold):
        try:
            current_cylinder_state = self._state_proxy(cylinder_name, "world")
        except rospy.ServiceException as exc:
            clientLogger.info(str(exc))
            return False
        return current_cylinder_state.pose.position.z < z_threshold



arm_state = rospy.Publisher(
    '/arm_robot/arm_commands', String, latch=True, queue_size=10)
hand_state = rospy.Publisher(
    '/arm_robot/hand_commands', String, latch=True, queue_size=10)


def notify_user_cb(adv_message):
    @smach.cb_interface(input_keys=[], output_keys=[], outcomes=['finished'])
    def fun(user_data):
        clientLogger.advertise(adv_message)
        return 'finished'
    return fun


def send_hand_command(command):
    @smach.cb_interface(input_keys=[], output_keys=[], outcomes=['finished', 'preempted'])
    def fun(user_data):
        hand_state.publish(command)
        return 'finished'
    return fun

def send_arm_command(command):
    @smach.cb_interface(input_keys=[], output_keys=[], outcomes=['finished', 'preempted'])
    def fun(user_data):
        
        arm_state.publish(command)
        return 'finished'
    return fun
def approach_cb():

    return send_arm_command('APPROACH')


def grasp_move_cb():
    return send_arm_command('GRASP')


def throw_cb():
    return send_arm_command('THROW')


def reset_arm_cb():
    return send_arm_command('RESET')


def open_hand_cb():
    return send_hand_command("RELEASE")


def close_hand_cb():
    return send_hand_command("GRASP")


def model_state_msg():
    ms_msg = ModelState()
    ms_msg.model_name = '_cylinder'
    # set orientation RYP axes
    ms_msg.pose.position.x = -0.37797
    ms_msg.pose.position.y = -0.25321
    ms_msg.pose.position.z = 1.12015
    # reference frame
    ms_msg.reference_frame = 'world'
    ms_msg.scale.x = ms_msg.scale.y = ms_msg.scale.z = 1.0
    return ms_msg


gazebo_set_model_state_service = '/gazebo/set_model_state'


FINISHED = 'FINISHED'
ERROR = 'ERROR'
PREEMPTED = 'PREEMPTED'

sm = StateMachine(outcomes=[FINISHED, ERROR, PREEMPTED])


with sm:
    
    StateMachine.add(
        "new_cylinder",
        NewCylinderState(cylinder_name, cylinder_sdf_xml),
        transitions = {"success": "initial_wait_condition",
                     "aborted": ERROR}
    )
    
    
    StateMachine.add(
        "initial_wait_condition",
        WaitToClockState(2),
        transitions={'valid': 'initial_wait_condition',
                     'invalid': 'display_description',
                     'preempted': PREEMPTED}
    )
    StateMachine.add(
        "display_description",
        CBState(notify_user_cb("In this demo, the Hollie arm robot will clear the table, "
                               "disposing of the objects into the appropriate container.")),
        transitions={'finished': 'reset_arm'}
    )
    StateMachine.add(
        'reset_arm',
        CBState(reset_arm_cb()),
        transitions={'finished': 'wait_reset',
                     'preempted': PREEMPTED}
    )
    StateMachine.add(
        'wait_reset',
        ClockDelayState(3),
        transitions={'valid': 'wait_reset',
                     'invalid': 'reposition',
                     'preempted': PREEMPTED}
    )

    StateMachine.add(
        'reposition',
        ServiceState(gazebo_set_model_state_service,
                     SetModelState, request=model_state_msg()),
        transitions={'succeeded': 'wait_condition',
                     'preempted': PREEMPTED,
                     'aborted': ERROR})

    StateMachine.add(
        "wait_condition",
        ClockDelayState(3),
        transitions={'valid': 'wait_condition',
                     'invalid': 'approach',
                     'preempted': PREEMPTED}
    )

    StateMachine.add(
        'approach',
        CBState(approach_cb()),
        transitions={'finished': 'wait_approach',
                     
                     'preempted': PREEMPTED}
    )

    StateMachine.add(
        "wait_approach",
        ClockDelayState(2),
        transitions={'valid': 'wait_approach',
                     'invalid': 'grasp_move',
                     'preempted': PREEMPTED}
    )

    StateMachine.add(
        "grasp_move",
        CBState(grasp_move_cb()),
        transitions={'finished': 'close_hand',
                     
                     'preempted': PREEMPTED}
    )

    StateMachine.add(
        'close_hand',
        CBState(close_hand_cb()),
        transitions={'finished': 'wait_close_hand',
                     'preempted': PREEMPTED}
    )

    StateMachine.add(
        "wait_close_hand",
        ClockDelayState(2),
        transitions={'valid': 'wait_close_hand',
                     'invalid': 'throw',
                     'preempted': PREEMPTED}
    )

    StateMachine.add(
        'throw',
        CBState(throw_cb()),
        transitions={'finished': 'open_hand',
                     'preempted': PREEMPTED}
    )

    StateMachine.add(
        'open_hand',
        CBState(open_hand_cb()),
        transitions={'finished': 'wait_open_hand',
                     'preempted': PREEMPTED}
    )

    StateMachine.add(
        'wait_open_hand',
        ClockDelayState(4),
        transitions={'valid': 'wait_open_hand',
                     'invalid': 'display_clear_message',
                     'preempted': PREEMPTED}
    )

    
    StateMachine.add(
        "flying_cylinder",
        FlyingCylinderState(cylinder_name),
        transitions = {"success": "display_clear_message",
                    "aborted": ERROR}
    )

    StateMachine.add(
        "display_clear_message",
        CBState(
            notify_user_cb(
                "The Table is clear! Getting back into resting position...")),
        transitions={'finished': 'new_cylinder'}
    )